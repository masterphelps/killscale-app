import React from 'react';
import { Subtitles } from 'lucide-react';
import { TimelineItemLabel } from './timeline-item-label';
import { Caption } from '../../../../../types';
import { BaseItemContentProps } from '../timeline-item-content-factory';

interface CaptionItemContentProps extends BaseItemContentProps {
  data?: {
    text?: string;
    language?: string;
    speaker?: string;
    confidence?: number; // For auto-generated captions
    isAutoGenerated?: boolean;
    wordTimings?: Array<{
      word: string;
      start: number;
      end: number;
      confidence?: number;
    }>;
    // Enhanced caption data with the new structure
    captions?: Caption[]; // Array of caption objects with words and timing
  };
}

export const CaptionItemContent: React.FC<CaptionItemContentProps> = ({
  label,
  data,
  start,
  end,
  isHovering = false, // Default to false
  currentFrame,
  fps = 30,
}) => {
  
  // Calculate duration and frame information
  const durationInSeconds = end - start;
  
  // Use captions from data if available, otherwise fall back to simple text
  const captions = data?.captions || [];
  const totalDurationSeconds = durationInSeconds;
  
  // Determine if we should show the simple label or detailed word blocks
  // Simplified: just check if duration is too long (> 20 seconds)
  const shouldShowLabel = totalDurationSeconds > 20;

  if (shouldShowLabel || !captions.length) {
    // Simple label mode for zoomed out view or when no detailed caption data is available
    const totalWords = captions.reduce(
      (sum, caption) => sum + caption.words.length,
      0
    );

    const iconClassName = `w-3 h-3 ${data?.isAutoGenerated ? 'text-yellow-400' : 'text-white/80'}`;

    // If we have caption data, show enhanced label with word count
    if (captions.length > 0) {
      return (
        <div className="flex items-center h-full w-full overflow-hidden px-2 transition-all duration-200 ease-out bg-caption-item">
          <div className={`flex items-center min-w-0 w-full overflow-hidden transition-all duration-200 ease-out ${
            isHovering ? 'ml-6' : 'ml-4'
          }`}>
            <div className="flex items-center p-1 rounded-sm overflow-hidden bg-caption-overlay/90">
              <div className="flex-shrink-0 mr-2 flex items-center overflow-hidden">
                <Subtitles className="w-4 h-4 flex-shrink-0 text-caption-item-active-foreground" />
              </div>
              <div className="min-w-0 overflow-hidden">
                <div className="truncate text-xs font-normal whitespace-nowrap text-caption-item-active-foreground">
 CAPTIONS   ({totalWords} words)
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    } else {
      // Fall back to the original simple label
      return (
        <TimelineItemLabel 
          icon={Subtitles}
          label={"Subtitles"} // Not sure where label is coming from so just hard coding for now
          defaultLabel="CAPTION"
          iconClassName={iconClassName}
          isHovering={isHovering} // Pass hover state
        />
      );
    }
  }

  // Detailed mode - show individual words as blocks
  // Use a consistent font size
  const getFontSize = () => {
    return '10px'; // Fixed size for simplicity
  };

  // Calculate current time in milliseconds relative to this item's start
  // Convert current frame to time and subtract item start time to get relative position
  const currentTimeInSeconds = currentFrame ? currentFrame / fps : 0;
  const itemRelativeTimeInSeconds = currentTimeInSeconds - start;
  const currentMs = itemRelativeTimeInSeconds * 1000; // Convert to milliseconds

  return (
    <div className="absolute inset-0 flex w-full h-full z-10 pointer-events-none bg-caption-item">
      {captions?.map((caption, index) => {
        const captionWidth =
          ((caption.endMs - caption.startMs) /
            (durationInSeconds * 1000)) *
          100;

        return (
          <div
            key={index}
            className="h-full flex items-center justify-start pointer-events-auto"
            style={{
              width: `${captionWidth}%`,
              left: `${
                (caption.startMs / (durationInSeconds * 1000)) * 100
              }%`,
              position: "absolute",
            }}
          >
            {caption.words.map((word, wordIndex) => {
              const wordWidth =
                ((word.endMs - word.startMs) /
                  (caption.endMs - caption.startMs)) *
                100;
              const isWordActive =
                currentMs >= word.startMs && currentMs < word.endMs;

              return (
                <div
                  key={wordIndex}
                  className={`flex p-[3px] items-center justify-center mx-[1px] rounded-[3px] transition-all duration-150 ${
                    isWordActive ? "bg-caption-item-active " : "bg-caption-item-foreground"
                  }`}
                  style={{
                    width: `${wordWidth}%`,
                  }}
                >
                  <span
                    className={`truncate ${
                      isWordActive ? "text-white font-medium " : "text-white"
                    }`}
                    style={{
                      fontSize: getFontSize(),
                    }}
                  >
                    {word.word}
                  </span>
                </div>
              );
            })}
          </div>
        );
      })}
    </div>
  );
}; 